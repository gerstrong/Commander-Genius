<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Commander Genius: FindFile.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>FindFile.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">//   OpenLieroX</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">//   Auxiliary Software class library</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">//   based on the work of JasonB</span>
<a name="l00008"></a>00008 <span class="comment">//   enhanced by Dark Charlie and Albert Zeyer</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">//   code under LGPL</span>
<a name="l00011"></a>00011 <span class="comment">//</span><span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">/////////////////////////////////////////</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="comment">// File finding routines</span>
<a name="l00016"></a>00016 <span class="comment">// Created 30/9/01</span>
<a name="l00017"></a>00017 <span class="comment">// By Jason Boettcher</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable: 4786)  // WARNING: identifier XXX was truncated to 255 characters in the debug info</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable: 4503)  // WARNING: decorated name length exceeded, name was truncated</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;FindFile.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;StringUtils.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;Debug.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;ConfigHandler.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;sdl/CSettings.h&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor"># ifndef _WIN32_IE</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="comment">// Some functions that are required are unavailable if this is not defined:</span>
<a name="l00036"></a>00036 <span class="comment">// TODO: which functions?</span>
<a name="l00037"></a>00037 <span class="preprocessor">#   define  _WIN32_IE  0x0400  // Because of Dev-cpp</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="preprocessor"># include &lt;shlobj.h&gt;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#else // WIN32</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="comment">// not defined for older GCC versions; we check only for &gt;=4.3 anyway</span>
<a name="l00045"></a>00045 <span class="preprocessor"># ifndef __GNUC_PREREQ</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">#  define __GNUC_PREREQ(maj, min) (0)</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a>00049 <span class="comment">// include hash_set support</span>
<a name="l00050"></a>00050 <span class="preprocessor"># if !defined(STLPORT)</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#  if defined(__GNUC__) &amp;&amp;  __GNUC_PREREQ(4,3)</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;tr1/unordered_set&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#   define hash_set std::tr1::unordered_set</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;ext/hash_set&gt;</span>
<a name="l00056"></a>00056 <span class="keyword">using</span> __gnu_cxx::hash_set;
<a name="l00057"></a>00057 <span class="preprocessor">#  endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor"># else // STLPORT</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;hash_set&gt;</span>
<a name="l00060"></a>00060 <span class="keyword">using</span> std::hash_set;
<a name="l00061"></a>00061 <span class="preprocessor"># endif</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="comment">// for getpwduid</span>
<a name="l00064"></a>00064 <span class="preprocessor"># include &lt;pwd.h&gt;</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">// for realpath</span>
<a name="l00067"></a>00067 <span class="preprocessor"># include &lt;sys/param.h&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor"># include &lt;unistd.h&gt;</span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="preprocessor">#endif</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="keywordtype">void</span> InitSearchPaths() {
<a name="l00075"></a>00075  <span class="comment">// have to set to find the config at some of the default places</span>
<a name="l00076"></a>00076  InitBaseSearchPaths();
<a name="l00077"></a>00077 
<a name="l00078"></a>00078  <span class="keywordtype">int</span> i = 1;
<a name="l00079"></a>00079  <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00080"></a>00080   std::string value;
<a name="l00081"></a>00081   <span class="keywordflow">if</span>(!ReadString(CONFIGFILENAME, <span class="stringliteral">&quot;FileHandling&quot;</span>, <span class="stringliteral">&quot;SearchPath&quot;</span> + itoa(i), value, <span class="stringliteral">&quot;&quot;</span>))
<a name="l00082"></a>00082    <span class="keywordflow">break</span>;
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   AddToFileList(&amp;tSearchPaths, value);
<a name="l00085"></a>00085   i++;
<a name="l00086"></a>00086  }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088  <span class="comment">// add the basesearchpaths to the searchpathlist as they should be saved in the end</span>
<a name="l00089"></a>00089  <span class="keywordflow">for</span>(searchpathlist::const_iterator p1 = basesearchpaths.begin(); p1 != basesearchpaths.end(); i++,p1++)  {
<a name="l00090"></a>00090   AddToFileList(&amp;tSearchPaths, *p1);
<a name="l00091"></a>00091  }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093  <span class="comment">// print the searchpaths, this may be very usefull for the user</span>
<a name="l00094"></a>00094  notes &lt;&lt; <span class="stringliteral">&quot;I have now the following searchpaths (in this order):\n&quot;</span>;
<a name="l00095"></a>00095  <span class="keywordflow">for</span>(searchpathlist::const_iterator p2 = tSearchPaths.begin(); p2 != tSearchPaths.end(); p2++) {
<a name="l00096"></a>00096   std::string path = *p2;
<a name="l00097"></a>00097   ReplaceFileVariables(path);
<a name="l00098"></a>00098   notes &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; path &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00099"></a>00099  }
<a name="l00100"></a>00100  notes &lt;&lt; <span class="stringliteral">&quot; And that&#39;s all.&quot;</span> &lt;&lt; endl;
<a name="l00101"></a>00101 }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 searchpathlist tSearchPaths;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="keywordtype">bool</span> IsFileAvailable(<span class="keyword">const</span> std::string&amp; f, <span class="keywordtype">bool</span> absolute) {
<a name="l00110"></a>00110  std::string abs_f;
<a name="l00111"></a>00111  <span class="keywordflow">if</span>(absolute) {
<a name="l00112"></a>00112   abs_f = f;
<a name="l00113"></a>00113  } <span class="keywordflow">else</span>
<a name="l00114"></a>00114   <span class="keywordflow">if</span>((abs_f = GetFullFileName(f)) == <span class="stringliteral">&quot;&quot;</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116  <span class="comment">// remove trailing slashes</span>
<a name="l00117"></a>00117  <span class="comment">// don&#39;t remove them on WIN, if it is a drive-letter</span>
<a name="l00118"></a>00118  <span class="keywordflow">while</span>(abs_f.size() &gt; 0 &amp;&amp; (abs_f[abs_f.size()-1] == <span class="charliteral">&#39;\\&#39;</span> || abs_f[abs_f.size()-1] == <span class="charliteral">&#39;/&#39;</span>)) {
<a name="l00119"></a>00119 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(abs_f.size() &gt; 2 &amp;&amp; abs_f[abs_f.size()-2] == <span class="charliteral">&#39;:&#39;</span>) <span class="keywordflow">break</span>;
<a name="l00121"></a>00121 <span class="preprocessor">#endif</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>  abs_f.erase(abs_f.size()-1);
<a name="l00123"></a>00123  }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125  abs_f = Utf8ToSystemNative(abs_f);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127  <span class="comment">// HINT: this should also work on WIN32, as we have _stat here</span>
<a name="l00128"></a>00128  <span class="keyword">struct </span>stat s;
<a name="l00129"></a>00129  <span class="keywordflow">if</span>(stat(abs_f.c_str(), &amp;s) != 0 || !S_ISREG(s.st_mode)) {
<a name="l00130"></a>00130   <span class="comment">// it&#39;s not stat-able or not a reg file</span>
<a name="l00131"></a>00131   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00132"></a>00132  }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134  <span class="comment">// it&#39;s stat-able and a file</span>
<a name="l00135"></a>00135  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00136"></a>00136 }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="comment"></span>
<a name="l00140"></a>00140 <span class="comment">//////////////////////</span>
<a name="l00141"></a>00141 <span class="comment"></span><span class="comment">// Replaces backward slashes with forward slashes (windows only)</span>
<a name="l00142"></a>00142 <span class="comment">// Used when comparing two paths</span>
<a name="l00143"></a>00143 <span class="keyword">static</span> <span class="keywordtype">void</span> ReplaceSlashes(std::string&amp; path)  {
<a name="l00144"></a>00144 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span> <span class="keywordflow">for</span> (std::string::iterator it = path.begin(); it != path.end(); it++)
<a name="l00146"></a>00146   <span class="keywordflow">if</span> (*it == <span class="charliteral">&#39;\\&#39;</span>) *it = <span class="charliteral">&#39;/&#39;</span>;
<a name="l00147"></a>00147 <span class="preprocessor">#endif</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>}
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="keywordtype">bool</span> EqualPaths(<span class="keyword">const</span> std::string&amp; path1, <span class="keyword">const</span> std::string&amp; path2)  {
<a name="l00151"></a>00151  std::string p1 = path1;
<a name="l00152"></a>00152  std::string p2 = path2;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154  ReplaceSlashes(p1);
<a name="l00155"></a>00155  ReplaceSlashes(p2);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157  <span class="keywordflow">if</span> (*p1.rbegin() != <span class="charliteral">&#39;/&#39;</span>)
<a name="l00158"></a>00158   p1 += <span class="charliteral">&#39;/&#39;</span>;
<a name="l00159"></a>00159  <span class="keywordflow">if</span> (*p2.rbegin() != <span class="charliteral">&#39;/&#39;</span>)
<a name="l00160"></a>00160   p2 += <span class="charliteral">&#39;/&#39;</span>;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162  <span class="keywordflow">return</span> stringcaseequal(p1, p2);
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">/*</span>
<a name="l00166"></a>00166 <span class="comment"></span>
<a name="l00167"></a>00167 <span class="comment"> Drives</span>
<a name="l00168"></a>00168 <span class="comment"></span>
<a name="l00169"></a>00169 <span class="comment"> */</span>
<a name="l00170"></a>00170 <span class="comment"></span>
<a name="l00171"></a>00171 <span class="comment">////////////////////</span>
<a name="l00172"></a>00172 <span class="comment"></span><span class="comment">//</span>
<a name="l00173"></a>00173 drive_list GetDrives()
<a name="l00174"></a>00174 {
<a name="l00175"></a>00175  <span class="keyword">static</span> drive_list list;
<a name="l00176"></a>00176  list.clear();
<a name="l00177"></a>00177 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span> <span class="keyword">static</span> <span class="keywordtype">char</span> drives[34];
<a name="l00179"></a>00179  <span class="keywordtype">int</span> len = GetLogicalDriveStrings(<span class="keyword">sizeof</span>(drives),drives); <span class="comment">// Get the list of drives</span>
<a name="l00180"></a>00180  <a class="code" href="structdrive__t.html">drive_t</a> tmp;
<a name="l00181"></a>00181  <span class="keywordflow">if</span> (len)  {
<a name="l00182"></a>00182   <span class="keywordflow">for</span> (<span class="keyword">register</span> <span class="keywordtype">int</span> i=0; i&lt;len; i+=(int)strnlen(&amp;drives[i],4)+1)  {
<a name="l00183"></a>00183    <span class="comment">// Create the name (for example: C:\)</span>
<a name="l00184"></a>00184    tmp.name = &amp;drives[i];
<a name="l00185"></a>00185    <span class="comment">// Get the type</span>
<a name="l00186"></a>00186    tmp.type = GetDriveType((LPCTSTR)tmp.name.c_str());
<a name="l00187"></a>00187    <span class="comment">// Add to the list</span>
<a name="l00188"></a>00188    list.push_back(tmp);
<a name="l00189"></a>00189   }
<a name="l00190"></a>00190  }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="preprocessor">#else</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span> <span class="comment">// there are not any drives on Linux/Unix/MacOSX/...</span>
<a name="l00195"></a>00195  <span class="comment">// it&#39;s only windows which uses this crazy drive-letters</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197  <span class="comment">// perhaps not the best way</span>
<a name="l00198"></a>00198  <span class="comment">// home-dir of user is in other applications the default</span>
<a name="l00199"></a>00199  <span class="comment">// but it&#39;s always possible to read most other stuff</span>
<a name="l00200"></a>00200  <span class="comment">// and it&#39;s not uncommon that a user hase a shared dir like /mp3s</span>
<a name="l00201"></a>00201  <a class="code" href="structdrive__t.html">drive_t</a> tmp;
<a name="l00202"></a>00202  tmp.name = <span class="stringliteral">&quot;/&quot;</span>;
<a name="l00203"></a>00203  tmp.type = 0;
<a name="l00204"></a>00204  list.push_back(tmp);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206  <span class="comment">// we could communicate with dbus and ask it for all connected</span>
<a name="l00207"></a>00207  <span class="comment">// and mounted hardware-stuff</span>
<a name="l00208"></a>00208 <span class="preprocessor">#endif</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span>
<a name="l00210"></a>00210  <span class="keywordflow">return</span> list;
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span>
<a name="l00216"></a>00216 <span class="comment">// checks, if path is statable (that means, it&#39;s existing)</span>
<a name="l00217"></a>00217 <span class="comment">// HINT: absolute path and there is not case fixing</span>
<a name="l00218"></a>00218 <span class="comment">// (used by GetExactFileName)</span>
<a name="l00219"></a>00219 <span class="keywordtype">bool</span> IsPathStatable(<span class="keyword">const</span> std::string&amp; f) {
<a name="l00220"></a>00220  std::string abs_f = f;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222  <span class="comment">// remove trailing slashes</span>
<a name="l00223"></a>00223  <span class="comment">// don&#39;t remove them on WIN, if it is a drive-letter</span>
<a name="l00224"></a>00224  <span class="keywordflow">while</span>(abs_f.size() &gt; 0 &amp;&amp; (abs_f[abs_f.size()-1] == <span class="charliteral">&#39;\\&#39;</span> || abs_f[abs_f.size()-1] == <span class="charliteral">&#39;/&#39;</span>)) {
<a name="l00225"></a>00225 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(abs_f.size() &gt; 2 &amp;&amp; abs_f[abs_f.size()-2] == <span class="charliteral">&#39;:&#39;</span>) <span class="keywordflow">break</span>;
<a name="l00227"></a>00227 <span class="preprocessor">#endif</span>
<a name="l00228"></a>00228 <span class="preprocessor"></span>  abs_f.erase(abs_f.size()-1);
<a name="l00229"></a>00229  }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231  <span class="comment">// HINT: this should also work on WIN32, as we have _stat here</span>
<a name="l00232"></a>00232  <span class="keyword">struct </span>stat s;
<a name="l00233"></a>00233 <span class="preprocessor">#ifdef WIN32  // uses UTF16</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span> <span class="keywordflow">return</span> (wstat(Utf8ToUtf16(abs_f).c_str(), &amp;s) == 0); <span class="comment">// ...==0, if successfull</span>
<a name="l00235"></a>00235 <span class="preprocessor">#else // other systems</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span> <span class="keywordflow">return</span> (stat(abs_f.c_str(), &amp;s) == 0); <span class="comment">// ...==0, if successfull</span>
<a name="l00237"></a>00237 <span class="preprocessor">#endif</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span>}
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="comment">// used by unix-GetExactFileName</span>
<a name="l00242"></a>00242 <span class="comment">// HINT: it only reads the first char of the seperators</span>
<a name="l00243"></a>00243 <span class="comment">// it returns the start of the subdir (the pos _after_ the sep.)</span>
<a name="l00244"></a>00244 <span class="comment">// HINT: it returns position in bytes, not in characters</span>
<a name="l00245"></a>00245 <span class="keywordtype">size_t</span> GetNextName(<span class="keyword">const</span> std::string&amp; fullname, <span class="keyword">const</span> <span class="keywordtype">char</span>** seperators, std::string&amp; nextname)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247  std::string::const_iterator pos;
<a name="l00248"></a>00248  <span class="keywordtype">size_t</span> p = 0;
<a name="l00249"></a>00249  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251  <span class="keywordflow">for</span>(pos = fullname.begin(); pos != fullname.end(); pos++, p++) {
<a name="l00252"></a>00252   <span class="keywordflow">for</span>(i = 0; seperators[i] != NULL; i++)
<a name="l00253"></a>00253    <span class="keywordflow">if</span>(*pos == seperators[i][0]) {
<a name="l00254"></a>00254     nextname = fullname.substr(0, p);
<a name="l00255"></a>00255     <span class="keywordflow">return</span> p + 1;
<a name="l00256"></a>00256    }
<a name="l00257"></a>00257  }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259  nextname = fullname;
<a name="l00260"></a>00260  <span class="keywordflow">return</span> 0;
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="comment">// get ending filename of a path</span>
<a name="l00264"></a>00264 <span class="keywordtype">size_t</span> GetLastName(<span class="keyword">const</span> std::string&amp; fullname, <span class="keyword">const</span> <span class="keywordtype">char</span>** seperators)
<a name="l00265"></a>00265 {
<a name="l00266"></a>00266  std::string::const_reverse_iterator pos;
<a name="l00267"></a>00267  <span class="keywordtype">size_t</span> p = fullname.size()-1;
<a name="l00268"></a>00268  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270  <span class="keywordflow">for</span>(pos = fullname.rbegin(); pos != fullname.rend(); pos++, p--) {
<a name="l00271"></a>00271   <span class="keywordflow">for</span>(i = 0; seperators[i] != NULL; i++)
<a name="l00272"></a>00272    <span class="keywordflow">if</span>(*pos == seperators[i][0]) {
<a name="l00273"></a>00273     <span class="keywordflow">return</span> p;
<a name="l00274"></a>00274    }
<a name="l00275"></a>00275  }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277  <span class="comment">// indicates that there is no more sep</span>
<a name="l00278"></a>00278  <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)(-1);
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="keyword">struct </span>strcasecomparer {
<a name="l00284"></a>00284  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> std::string&amp; str1, <span class="keyword">const</span> std::string&amp; str2)<span class="keyword"> const </span>{
<a name="l00285"></a>00285   <span class="keywordflow">return</span> stringcaseequal(str1, str2);
<a name="l00286"></a>00286  }
<a name="l00287"></a>00287 };
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="keyword">typedef</span> hash_set&lt;std::string, simple_reversestring_hasher, strcasecomparer&gt; exactfilenamecache_t;
<a name="l00290"></a>00290 <span class="keyword">struct </span>ExactFilenameCache {
<a name="l00291"></a>00291  exactfilenamecache_t cache;
<a name="l00292"></a>00292  <a class="code" href="class_mutex.html">Mutex</a> mutex;
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 exactfilenamecache;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="keywordtype">bool</span> is_searchname_in_exactfilenamecache(
<a name="l00297"></a>00297            <span class="keyword">const</span> std::string&amp; searchname,
<a name="l00298"></a>00298            std::string&amp; exactname
<a name="l00299"></a>00299            ) {
<a name="l00300"></a>00300  <a class="code" href="struct_mutex_1_1_scoped_lock.html">Mutex::ScopedLock</a> lock(exactfilenamecache.mutex);
<a name="l00301"></a>00301  exactfilenamecache_t::iterator it = exactfilenamecache.cache.find(searchname);
<a name="l00302"></a>00302  <span class="keywordflow">if</span>(it != exactfilenamecache.cache.end()) {
<a name="l00303"></a>00303   exactname = *it;
<a name="l00304"></a>00304   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00305"></a>00305  } <span class="keywordflow">else</span>
<a name="l00306"></a>00306   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="keywordtype">void</span> add_searchname_to_exactfilenamecache(<span class="keyword">const</span> std::string&amp; exactname) {
<a name="l00310"></a>00310  <a class="code" href="struct_mutex_1_1_scoped_lock.html">Mutex::ScopedLock</a> lock(exactfilenamecache.mutex);
<a name="l00311"></a>00311  exactfilenamecache.cache.insert(exactname);
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="comment">// used by unix-GetExactFileName</span>
<a name="l00316"></a>00316 <span class="comment">// does a case insensitive search for searchname in dir</span>
<a name="l00317"></a>00317 <span class="comment">// sets filename to the first search result</span>
<a name="l00318"></a>00318 <span class="comment">// returns true, if any file found</span>
<a name="l00319"></a>00319 <span class="keywordtype">bool</span> CaseInsFindFile(<span class="keyword">const</span> std::string&amp; dir, <span class="keyword">const</span> std::string&amp; searchname, std::string&amp; filename) {
<a name="l00320"></a>00320  <span class="keywordflow">if</span>(searchname == <span class="stringliteral">&quot;&quot;</span>) {
<a name="l00321"></a>00321   filename = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00322"></a>00322   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00323"></a>00323  }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325  <span class="comment">// Check first if searchname perhaps exists with exactly this name.</span>
<a name="l00326"></a>00326  <span class="comment">// This check is also needed in the case if we cannot read dir (-r) but we can access files (+x) in it.</span>
<a name="l00327"></a>00327  <span class="keywordflow">if</span>(IsPathStatable((dir == <span class="stringliteral">&quot;&quot;</span>) ? searchname : (dir + <span class="stringliteral">&quot;/&quot;</span> + searchname))) {
<a name="l00328"></a>00328   filename = searchname;
<a name="l00329"></a>00329   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00330"></a>00330  }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332  DIR* dirhandle = opendir((dir == <span class="stringliteral">&quot;&quot;</span>) ? <span class="stringliteral">&quot;.&quot;</span> : dir.c_str());
<a name="l00333"></a>00333  <span class="keywordflow">if</span>(dirhandle == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335  dirent* direntry;
<a name="l00336"></a>00336  <span class="keywordflow">while</span>((direntry = readdir(dirhandle))) {
<a name="l00337"></a>00337   <span class="keywordflow">if</span>(strcasecmp(direntry-&gt;d_name, searchname.c_str()) == 0) {
<a name="l00338"></a>00338    filename = direntry-&gt;d_name;
<a name="l00339"></a>00339    closedir(dirhandle);
<a name="l00340"></a>00340 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span>   <span class="comment">// HINT: activate this warning temporarly when you want to fix some filenames</span>
<a name="l00342"></a>00342    <span class="comment">//if(filename != searchname)</span>
<a name="l00343"></a>00343    <span class="comment">// cerr &lt;&lt; &quot;filename case mismatch: &quot; &lt;&lt; searchname &lt;&lt; &quot; &lt;-&gt; &quot; &lt;&lt; filename &lt;&lt; endl;</span>
<a name="l00344"></a>00344 <span class="preprocessor">#endif</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span>   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00346"></a>00346   }
<a name="l00347"></a>00347   add_searchname_to_exactfilenamecache((dir == <span class="stringliteral">&quot;&quot;</span>) ? direntry-&gt;d_name : (dir + <span class="stringliteral">&quot;/&quot;</span> + direntry-&gt;d_name));
<a name="l00348"></a>00348  }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350  closedir(dirhandle);
<a name="l00351"></a>00351  <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00352"></a>00352 }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">// does case insensitive search for file</span>
<a name="l00357"></a>00357 <span class="keywordtype">bool</span> GetExactFileName(<span class="keyword">const</span> std::string&amp; abs_searchname, std::string&amp; filename) {
<a name="l00358"></a>00358  <span class="keyword">const</span> <span class="keywordtype">char</span>* seps[] = {<span class="stringliteral">&quot;\\&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>, (<span class="keywordtype">char</span>*)NULL};
<a name="l00359"></a>00359  <span class="keywordflow">if</span>(abs_searchname.size() == 0) {
<a name="l00360"></a>00360   filename = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00361"></a>00361   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00362"></a>00362  }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364  std::string sname = abs_searchname;
<a name="l00365"></a>00365  ReplaceFileVariables(sname);
<a name="l00366"></a>00366 
<a name="l00367"></a>00367  std::string nextname = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00368"></a>00368  std::string nextexactname = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00369"></a>00369  <span class="keywordtype">size_t</span> pos;
<a name="l00370"></a>00370 
<a name="l00371"></a>00371  <span class="keywordtype">bool</span> first_iter = <span class="keyword">true</span>; <span class="comment">// this is used in the bottom loop</span>
<a name="l00372"></a>00372 
<a name="l00373"></a>00373  <span class="comment">// search in cache</span>
<a name="l00374"></a>00374 
<a name="l00375"></a>00375  <span class="comment">// sname[0..pos-1] is left rest, excluding the /</span>
<a name="l00376"></a>00376  pos = sname.size();
<a name="l00377"></a>00377  std::string rest;
<a name="l00378"></a>00378  <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00379"></a>00379   rest = sname.substr(0,pos);
<a name="l00380"></a>00380   <span class="keywordflow">if</span>(is_searchname_in_exactfilenamecache(rest, filename)) {
<a name="l00381"></a>00381    <span class="keywordflow">if</span>(IsPathStatable(filename)) {
<a name="l00382"></a>00382     <span class="keywordflow">if</span>(pos == sname.size()) <span class="comment">// do we got the whole filename?</span>
<a name="l00383"></a>00383      <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     <span class="comment">// filename is the correct one here</span>
<a name="l00386"></a>00386     sname.erase(0,pos+1);
<a name="l00387"></a>00387     first_iter = <span class="keyword">false</span>; <span class="comment">// prevents the following loop from not adding a &quot;/&quot; to filename</span>
<a name="l00388"></a>00388     <span class="keywordflow">break</span>;
<a name="l00389"></a>00389    }
<a name="l00390"></a>00390   }
<a name="l00391"></a>00391   pos = GetLastName(rest, seps);
<a name="l00392"></a>00392   <span class="keywordflow">if</span>(pos == (<span class="keywordtype">size_t</span>)(-1)) {
<a name="l00393"></a>00393    first_iter = <span class="keyword">false</span>;
<a name="l00394"></a>00394    <span class="keywordflow">if</span>(rest == <span class="stringliteral">&quot;.&quot;</span> || rest == <span class="stringliteral">&quot;..&quot;</span>) {
<a name="l00395"></a>00395     filename = rest;
<a name="l00396"></a>00396     sname.erase(0,rest.size()+1);
<a name="l00397"></a>00397     <span class="keywordflow">break</span>;
<a name="l00398"></a>00398    }
<a name="l00399"></a>00399    filename = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l00400"></a>00400    <span class="keywordflow">break</span>;
<a name="l00401"></a>00401   }
<a name="l00402"></a>00402   <span class="keywordflow">if</span>(pos == 0) {
<a name="l00403"></a>00403    filename = <span class="stringliteral">&quot;/&quot;</span>;
<a name="l00404"></a>00404    sname.erase(0,1);
<a name="l00405"></a>00405    <span class="keywordflow">break</span>;
<a name="l00406"></a>00406   }
<a name="l00407"></a>00407  }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 
<a name="l00411"></a>00411  <span class="comment">// search the filesystem for the name</span>
<a name="l00412"></a>00412 
<a name="l00413"></a>00413  <span class="comment">// sname contains the rest of the path</span>
<a name="l00414"></a>00414  <span class="comment">// filename contains the start (including a &quot;/&quot; if necces.)</span>
<a name="l00415"></a>00415  <span class="comment">// if first_iter is set to true, don&#39;t add leading &quot;/&quot;</span>
<a name="l00416"></a>00416  <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00417"></a>00417   pos = GetNextName(sname, seps, nextname);
<a name="l00418"></a>00418   <span class="comment">// pos&gt;0  =&gt; found a sep (pos is right behind the sep)</span>
<a name="l00419"></a>00419   <span class="comment">// pos==0  =&gt; none found</span>
<a name="l00420"></a>00420   <span class="keywordflow">if</span>(pos &gt; 0) sname.erase(0,pos);
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="keywordflow">if</span>(nextname == <span class="stringliteral">&quot;&quot;</span>) {
<a name="l00423"></a>00423    <span class="comment">// simply ignore this case</span>
<a name="l00424"></a>00424    <span class="comment">// (we accept sth like /usr///share/)</span>
<a name="l00425"></a>00425    <span class="keywordflow">if</span>(pos == 0) <span class="keywordflow">break</span>;
<a name="l00426"></a>00426    <span class="keywordflow">continue</span>;
<a name="l00427"></a>00427   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!CaseInsFindFile(
<a name="l00428"></a>00428            filename, <span class="comment">// dir</span>
<a name="l00429"></a>00429            nextname, <span class="comment">// ~name</span>
<a name="l00430"></a>00430            nextexactname <span class="comment">// resulted name</span>
<a name="l00431"></a>00431            )) {
<a name="l00432"></a>00432    <span class="comment">// we doesn&#39;t get any result</span>
<a name="l00433"></a>00433    <span class="comment">// just add rest to it</span>
<a name="l00434"></a>00434    <span class="keywordflow">if</span>(!first_iter) filename += <span class="stringliteral">&quot;/&quot;</span>;
<a name="l00435"></a>00435    filename += nextname;
<a name="l00436"></a>00436    <span class="keywordflow">if</span>(pos &gt; 0) filename += <span class="stringliteral">&quot;/&quot;</span> + sname;
<a name="l00437"></a>00437    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// error (not found)</span>
<a name="l00438"></a>00438   }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="keywordflow">if</span>(!first_iter) filename += <span class="stringliteral">&quot;/&quot;</span>;
<a name="l00441"></a>00441   filename += nextexactname;
<a name="l00442"></a>00442   <span class="keywordflow">if</span>(nextexactname != <span class="stringliteral">&quot;&quot;</span>)
<a name="l00443"></a>00443    add_searchname_to_exactfilenamecache(filename);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="keywordflow">if</span>(pos == 0) <span class="keywordflow">break</span>;
<a name="l00446"></a>00446   first_iter = <span class="keyword">false</span>;
<a name="l00447"></a>00447  }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449  <span class="comment">// we got here after the full path was resolved successfully</span>
<a name="l00450"></a>00450  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00451"></a>00451 }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="preprocessor">#endif // not WIN32</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span>
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 searchpathlist basesearchpaths;
<a name="l00457"></a>00457 <span class="keywordtype">void</span> InitBaseSearchPaths() {
<a name="l00458"></a>00458  basesearchpaths.clear();
<a name="l00459"></a>00459 <span class="preprocessor">#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR)</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span> AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;${HOME}/Library/Application Support/Commander Genius&quot;</span>);
<a name="l00461"></a>00461  AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l00462"></a>00462  AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;${BIN}&quot;</span>);
<a name="l00463"></a>00463  AddToFileList(&amp;basesearchpaths, SYSTEM_DATA_DIR<span class="stringliteral">&quot;/commandergenius&quot;</span>); 
<a name="l00464"></a>00464 <span class="preprocessor">#elif defined(__APPLE__)</span>
<a name="l00465"></a>00465 <span class="preprocessor"></span> AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;${HOME}/Library/Application Support/Commander Genius&quot;</span>);
<a name="l00466"></a>00466  AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l00467"></a>00467  AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;${BIN}/../Resources&quot;</span>);
<a name="l00468"></a>00468  AddToFileList(&amp;basesearchpaths, SYSTEM_DATA_DIR<span class="stringliteral">&quot;/commandergenius&quot;</span>);
<a name="l00469"></a>00469 <span class="preprocessor">#elif defined(WIN32)</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span> AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;${HOME}/Commander Genius&quot;</span>);
<a name="l00471"></a>00471  AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l00472"></a>00472  AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;${BIN}&quot;</span>);
<a name="l00473"></a>00473 <span class="preprocessor">#else // all other systems (Linux, *BSD, OS/2, ...)</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span> AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;${HOME}/.CommanderGenius&quot;</span>);
<a name="l00475"></a>00475  AddToFileList(&amp;basesearchpaths, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l00476"></a>00476  AddToFileList(&amp;basesearchpaths, SYSTEM_DATA_DIR<span class="stringliteral">&quot;/commandergenius&quot;</span>); <span class="comment">// no use of ${SYSTEM_DATA}, because it is uncommon and could cause confusion to the user</span>
<a name="l00477"></a>00477 <span class="preprocessor">#endif</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span>}
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 <span class="keywordtype">void</span> CreateRecDir(<span class="keyword">const</span> std::string&amp; abs_filename, <span class="keywordtype">bool</span> last_is_dir) {
<a name="l00481"></a>00481  std::string tmp;
<a name="l00482"></a>00482  std::string::const_iterator f = abs_filename.begin();
<a name="l00483"></a>00483  <span class="keywordflow">for</span>(tmp = <span class="stringliteral">&quot;&quot;</span>; f != abs_filename.end(); f++) {
<a name="l00484"></a>00484   <span class="keywordflow">if</span>(*f == <span class="charliteral">&#39;\\&#39;</span> || *f == <span class="charliteral">&#39;/&#39;</span>)
<a name="l00485"></a>00485    mkdir(tmp.c_str(), 0777);
<a name="l00486"></a>00486   tmp += *f;
<a name="l00487"></a>00487  }
<a name="l00488"></a>00488  <span class="keywordflow">if</span>(last_is_dir)
<a name="l00489"></a>00489   mkdir(tmp.c_str(), 0777);
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 std::string GetFirstSearchPath() {
<a name="l00493"></a>00493  <span class="keywordflow">if</span>(tSearchPaths.size() &gt; 0)
<a name="l00494"></a>00494   <span class="keywordflow">return</span> tSearchPaths.front();
<a name="l00495"></a>00495  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(basesearchpaths.size() &gt; 0)
<a name="l00496"></a>00496   <span class="keywordflow">return</span> basesearchpaths.front();
<a name="l00497"></a>00497  <span class="keywordflow">else</span>
<a name="l00498"></a>00498   <span class="keywordflow">return</span> GetHomeDir();
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="keywordtype">size_t</span> FileSize(<span class="keyword">const</span> std::string&amp; path)
<a name="l00502"></a>00502 {
<a name="l00503"></a>00503  FILE *fp = fopen(path.c_str(), <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00504"></a>00504  <span class="keywordflow">if</span> (!fp)  {
<a name="l00505"></a>00505   fp = OpenGameFile(path, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00506"></a>00506   <span class="keywordflow">if</span> (!fp)
<a name="l00507"></a>00507    <span class="keywordflow">return</span> 0;
<a name="l00508"></a>00508  }
<a name="l00509"></a>00509  fseek(fp, 0, SEEK_END);
<a name="l00510"></a>00510  <span class="keywordtype">size_t</span> size = ftell(fp);
<a name="l00511"></a>00511  fclose(fp);
<a name="l00512"></a>00512  <span class="keywordflow">return</span> size;
<a name="l00513"></a>00513 }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 <span class="preprocessor">#define uchar unsigned char</span>
<a name="l00516"></a>00516 <span class="preprocessor"></span><span class="comment">// Checks if the given path is absolute</span>
<a name="l00517"></a>00517 <span class="keywordtype">bool</span> IsAbsolutePath(<span class="keyword">const</span> std::string&amp; path)
<a name="l00518"></a>00518 {
<a name="l00519"></a>00519 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span> <span class="comment">// The path must start with a drive letter</span>
<a name="l00521"></a>00521  <span class="keywordflow">if</span> (path.size() &lt; 2)
<a name="l00522"></a>00522   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524  <span class="keywordflow">return</span> (isalpha((uchar)path[0]) &amp;&amp; path[1] == <span class="charliteral">&#39;:&#39;</span>);
<a name="l00525"></a>00525 <span class="preprocessor">#else</span>
<a name="l00526"></a>00526 <span class="preprocessor"></span> <span class="comment">// Must start with a slash</span>
<a name="l00527"></a>00527  <span class="keywordflow">if</span> (!path.size())
<a name="l00528"></a>00528   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530  <span class="keywordflow">return</span> path[0] == <span class="charliteral">&#39;/&#39;</span>;
<a name="l00531"></a>00531 <span class="preprocessor">#endif</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span>}
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="keyword">static</span> std::string specialSearchPathForTheme = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00536"></a>00536 
<a name="l00537"></a>00537 <span class="keywordtype">void</span> initSpecialSearchPathForTheme() {
<a name="l00538"></a>00538  <span class="comment">/*if(tLXOptions-&gt;sTheme != &quot;&quot;) {</span>
<a name="l00539"></a>00539 <span class="comment">  specialSearchPathForTheme = GetFullFileName(&quot;themes/&quot; + tLXOptions-&gt;sTheme);</span>
<a name="l00540"></a>00540 <span class="comment">  } else */</span>
<a name="l00541"></a>00541  specialSearchPathForTheme = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00542"></a>00542 }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 <span class="keyword">const</span> std::string* getSpecialSearchPathForTheme() {
<a name="l00545"></a>00545  <span class="keywordflow">if</span>(specialSearchPathForTheme == <span class="stringliteral">&quot;&quot;</span>)
<a name="l00546"></a>00546   <span class="keywordflow">return</span> NULL;
<a name="l00547"></a>00547  <span class="keywordflow">else</span>
<a name="l00548"></a>00548   <span class="keywordflow">return</span> &amp;specialSearchPathForTheme;
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="keyword">class </span>CheckSearchpathForFile { <span class="keyword">public</span>:
<a name="l00553"></a>00553  <span class="keyword">const</span> std::string&amp; filename;
<a name="l00554"></a>00554  std::string* result;
<a name="l00555"></a>00555  std::string* searchpath;
<a name="l00556"></a>00556  CheckSearchpathForFile(<span class="keyword">const</span> std::string&amp; f, std::string* r, std::string* s) : filename(f), result(r), searchpath(s) {}
<a name="l00557"></a>00557 
<a name="l00558"></a>00558  <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> std::string&amp; spath) {
<a name="l00559"></a>00559   std::string tmp = spath + filename;
<a name="l00560"></a>00560   <span class="keywordflow">if</span>(GetExactFileName(tmp, *result)) {
<a name="l00561"></a>00561    <span class="comment">// we got here, if the file exists</span>
<a name="l00562"></a>00562    <span class="keywordflow">if</span>(searchpath) *searchpath = spath;
<a name="l00563"></a>00563    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// stop checking next searchpaths</span>
<a name="l00564"></a>00564   }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566   <span class="comment">// go to the next searchpath</span>
<a name="l00567"></a>00567   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00568"></a>00568  }
<a name="l00569"></a>00569 };
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 std::string GetFullFileName(<span class="keyword">const</span> std::string&amp; path, std::string* searchpath) {
<a name="l00572"></a>00572  <span class="keywordflow">if</span>(searchpath) *searchpath = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00573"></a>00573  <span class="keywordflow">if</span>(path == <span class="stringliteral">&quot;&quot;</span>) <span class="keywordflow">return</span> GetFirstSearchPath();
<a name="l00574"></a>00574 
<a name="l00575"></a>00575  <span class="comment">// Check if we have an absolute path</span>
<a name="l00576"></a>00576  <span class="keywordflow">if</span>(IsAbsolutePath(path)) {
<a name="l00577"></a>00577   std::string tmp;
<a name="l00578"></a>00578   GetExactFileName(path, tmp);
<a name="l00579"></a>00579   <span class="keywordflow">return</span> tmp;
<a name="l00580"></a>00580  }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582  std::string fname;
<a name="l00583"></a>00583  CheckSearchpathForFile checker(path, &amp;fname, searchpath);
<a name="l00584"></a>00584  ForEachSearchpath(checker);
<a name="l00585"></a>00585 
<a name="l00586"></a>00586  <span class="keywordflow">return</span> fname;
<a name="l00587"></a>00587 }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 std::string GetWriteFullFileName(<span class="keyword">const</span> std::string&amp; path, <span class="keywordtype">bool</span> create_nes_dirs) {
<a name="l00590"></a>00590  std::string tmp;
<a name="l00591"></a>00591  std::string fname;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593  <span class="comment">// get the dir, where we should write into</span>
<a name="l00594"></a>00594  <span class="keywordflow">if</span>(tSearchPaths.size() == 0 &amp;&amp; basesearchpaths.size() == 0) {
<a name="l00595"></a>00595   errors &lt;&lt; <span class="stringliteral">&quot;we want to write somewhere, but don&#39;t know where =&gt; we are writing to your temp-dir now...&quot;</span> &lt;&lt; endl;
<a name="l00596"></a>00596   tmp = GetTempDir() + <span class="stringliteral">&quot;/&quot;</span> + path;
<a name="l00597"></a>00597  } <span class="keywordflow">else</span> {
<a name="l00598"></a>00598   GetExactFileName(GetFirstSearchPath(), tmp);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600   CreateRecDir(tmp);
<a name="l00601"></a>00601   <span class="keywordflow">if</span>(!CanWriteToDir(tmp)) {
<a name="l00602"></a>00602    errors &lt;&lt; <span class="stringliteral">&quot;we cannot write to &quot;</span> &lt;&lt; tmp &lt;&lt; <span class="stringliteral">&quot; =&gt; we are writing to your temp-dir now...&quot;</span> &lt;&lt; endl;
<a name="l00603"></a>00603    tmp = GetTempDir();
<a name="l00604"></a>00604   }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   tmp += <span class="stringliteral">&quot;/&quot;</span>;
<a name="l00607"></a>00607   tmp += path;
<a name="l00608"></a>00608  }
<a name="l00609"></a>00609 
<a name="l00610"></a>00610  GetExactFileName(tmp, fname);
<a name="l00611"></a>00611  <span class="keywordflow">if</span>(create_nes_dirs) CreateRecDir(fname, <span class="keyword">false</span>);
<a name="l00612"></a>00612  <span class="keywordflow">return</span> tmp;
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 FILE* OpenAbsFile(<span class="keyword">const</span> std::string&amp; path, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode) {
<a name="l00616"></a>00616  std::string exactfn;
<a name="l00617"></a>00617  <span class="keywordflow">if</span>(!GetExactFileName(path, exactfn))
<a name="l00618"></a>00618   <span class="keywordflow">return</span> NULL;
<a name="l00619"></a>00619  <span class="keywordflow">return</span> fopen(exactfn.c_str(), mode);
<a name="l00620"></a>00620 }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 FILE *OpenGameFile(<span class="keyword">const</span> std::string&amp; path, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode) {
<a name="l00623"></a>00623  <span class="keywordflow">if</span>(path.size() == 0)
<a name="l00624"></a>00624   <span class="keywordflow">return</span> NULL;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626  std::string fullfn = GetFullFileName(path);
<a name="l00627"></a>00627 
<a name="l00628"></a>00628  <span class="keywordtype">bool</span> write_mode = strchr(mode, <span class="charliteral">&#39;w&#39;</span>) != 0;
<a name="l00629"></a>00629  <span class="keywordtype">bool</span> append_mode = strchr(mode, <span class="charliteral">&#39;a&#39;</span>) != 0;
<a name="l00630"></a>00630  <span class="keywordflow">if</span>(write_mode || append_mode) {
<a name="l00631"></a>00631   std::string writefullname = GetWriteFullFileName(path, <span class="keyword">true</span>);
<a name="l00632"></a>00632   <span class="keywordflow">if</span>(append_mode &amp;&amp; fullfn != <span class="stringliteral">&quot;&quot;</span>) { <span class="comment">// check, if we should copy the file</span>
<a name="l00633"></a>00633    <span class="keywordflow">if</span>(IsFileAvailable(fullfn, <span class="keyword">true</span>)) { <span class="comment">// we found the file</span>
<a name="l00634"></a>00634     <span class="comment">// GetWriteFullFileName ensures an exact filename,</span>
<a name="l00635"></a>00635     <span class="comment">// so no case insensitive check is needed here</span>
<a name="l00636"></a>00636     <span class="keywordflow">if</span>(fullfn != writefullname) {
<a name="l00637"></a>00637      <span class="comment">// it is not the file, we would write to, so copy it to the wanted destination</span>
<a name="l00638"></a>00638      <span class="keywordflow">if</span>(!FileCopy(fullfn, writefullname)) {
<a name="l00639"></a>00639       errors &lt;&lt; <span class="stringliteral">&quot;problems while copying, so I cannot open this file in append-mode somewhere else&quot;</span> &lt;&lt; endl;
<a name="l00640"></a>00640       <span class="keywordflow">return</span> NULL;
<a name="l00641"></a>00641      }
<a name="l00642"></a>00642     }
<a name="l00643"></a>00643    }
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645   <span class="comment">//errors &lt;&lt; &quot;opening file for writing (mode %s): %s\n&quot;, mode, writefullname);</span>
<a name="l00646"></a>00646   <span class="keywordflow">return</span> fopen(Utf8ToSystemNative(writefullname).c_str(), mode);
<a name="l00647"></a>00647  }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649  <span class="keywordflow">if</span>(fullfn.size() != 0) {
<a name="l00650"></a>00650   <span class="keywordflow">return</span> fopen(Utf8ToSystemNative(fullfn).c_str(), mode);
<a name="l00651"></a>00651  }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653  <span class="keywordflow">return</span> NULL;
<a name="l00654"></a>00654 }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 <span class="keywordtype">bool</span> OpenGameFileR(std::ifstream&amp; f, <span class="keyword">const</span> std::string&amp; path, std::ios_base::openmode mode) {
<a name="l00658"></a>00658  <span class="keywordflow">if</span>(path.size() == 0)
<a name="l00659"></a>00659   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661  std::string fullfn = GetFullFileName(path);
<a name="l00662"></a>00662  <span class="keywordflow">if</span>(fullfn.size() != 0) {
<a name="l00663"></a>00663   <span class="keywordflow">try</span> {
<a name="l00664"></a>00664    f.open(Utf8ToSystemNative(fullfn).c_str(), mode);
<a name="l00665"></a>00665    <span class="keywordflow">return</span> f.is_open();
<a name="l00666"></a>00666   } <span class="keywordflow">catch</span>(...) {}
<a name="l00667"></a>00667   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00668"></a>00668  }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670  <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="keywordtype">bool</span> OpenGameFileW(std::ofstream&amp; f, <span class="keyword">const</span> std::string&amp; path, std::ios_base::openmode mode) {
<a name="l00674"></a>00674  <span class="keywordflow">if</span>(path.size() == 0)
<a name="l00675"></a>00675   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677  std::string fullfn = GetWriteFullFileName(path, <span class="keyword">true</span>);
<a name="l00678"></a>00678  <span class="keywordflow">if</span>(fullfn.size() != 0) {
<a name="l00679"></a>00679   <span class="keywordflow">try</span> {
<a name="l00680"></a>00680    f.open(Utf8ToSystemNative(fullfn).c_str(), mode);
<a name="l00681"></a>00681    <span class="keywordflow">return</span> f.is_open();
<a name="l00682"></a>00682   } <span class="keywordflow">catch</span>(...) {}
<a name="l00683"></a>00683   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00684"></a>00684  }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686  <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00687"></a>00687 }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 <span class="keywordtype">void</span> AddToFileList(searchpathlist* l, <span class="keyword">const</span> std::string&amp; f) {
<a name="l00691"></a>00691  <span class="keywordflow">if</span>(!FileListIncludesExact(l, f)) l-&gt;push_back(f);
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="keywordtype">void</span> removeEndingSlashes(std::string&amp; s)
<a name="l00695"></a>00695 {
<a name="l00696"></a>00696  <span class="keywordflow">while</span>(s.size() &gt; 0 &amp;&amp; (*s.rbegin() == <span class="charliteral">&#39;\\&#39;</span> || *s.rbegin() == <span class="charliteral">&#39;/&#39;</span>))
<a name="l00697"></a>00697   s.erase(s.size() - 1);
<a name="l00698"></a>00698 }
<a name="l00699"></a>00699 <span class="comment"></span>
<a name="l00700"></a>00700 <span class="comment">/////////////////</span>
<a name="l00701"></a>00701 <span class="comment"></span><span class="comment">// Returns true, if the list contains the path</span>
<a name="l00702"></a>00702 <span class="keywordtype">bool</span> FileListIncludesExact(<span class="keyword">const</span> searchpathlist* l, <span class="keyword">const</span> std::string&amp; f) {
<a name="l00703"></a>00703  std::string tmp1 = f;
<a name="l00704"></a>00704  removeEndingSlashes(tmp1);
<a name="l00705"></a>00705  ReplaceFileVariables(tmp1);
<a name="l00706"></a>00706  replace(tmp1,<span class="stringliteral">&quot;\\&quot;</span>,<span class="stringliteral">&quot;/&quot;</span>);
<a name="l00707"></a>00707 
<a name="l00708"></a>00708  <span class="comment">// Go through the list, checking each item</span>
<a name="l00709"></a>00709  <span class="keywordflow">for</span>(searchpathlist::const_iterator i = l-&gt;begin(); i != l-&gt;end(); i++) {
<a name="l00710"></a>00710   std::string tmp2 = *i;
<a name="l00711"></a>00711   removeEndingSlashes(tmp2);
<a name="l00712"></a>00712   ReplaceFileVariables(tmp2);
<a name="l00713"></a>00713   replace(tmp2,<span class="stringliteral">&quot;\\&quot;</span>,<span class="stringliteral">&quot;/&quot;</span>);
<a name="l00714"></a>00714   <span class="keywordflow">if</span>(stringcaseequal(tmp1, tmp2))
<a name="l00715"></a>00715    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00716"></a>00716  }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718  <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00719"></a>00719 }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 std::string GetHomeDir() {
<a name="l00722"></a>00722 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00723"></a>00723 <span class="preprocessor"></span><span class="preprocessor">#if defined(WIZ) || defined(GP2X) || defined(DINGOO) || defined(PANDORA)</span>
<a name="l00724"></a>00724 <span class="preprocessor"></span> <span class="keywordtype">char</span>* home = getenv(<span class="stringliteral">&quot;PWD&quot;</span>);
<a name="l00725"></a>00725 <span class="preprocessor">#else</span>
<a name="l00726"></a>00726 <span class="preprocessor"></span> <span class="keywordtype">char</span>* home = getenv(<span class="stringliteral">&quot;HOME&quot;</span>);
<a name="l00727"></a>00727 <span class="preprocessor">#endif</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span> <span class="keywordflow">if</span>(home == NULL || home[0] == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00729"></a>00729   passwd* userinfo = getpwuid(getuid());
<a name="l00730"></a>00730   <span class="keywordflow">if</span>(userinfo)
<a name="l00731"></a>00731    <span class="keywordflow">return</span> userinfo-&gt;pw_dir;
<a name="l00732"></a>00732   <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>; <span class="comment">// both failed, very strange system...</span>
<a name="l00733"></a>00733  }
<a name="l00734"></a>00734  <span class="keywordflow">return</span> home;
<a name="l00735"></a>00735 <span class="preprocessor">#else</span>
<a name="l00736"></a>00736 <span class="preprocessor"></span> <span class="keyword">static</span> std::string result = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00737"></a>00737  <span class="keywordflow">if</span> (result.size() == 0)  {  <span class="comment">// Only do this once</span>
<a name="l00738"></a>00738   <span class="keywordtype">char</span> tmp[1024];
<a name="l00739"></a>00739   <span class="keywordflow">if</span> (!SHGetSpecialFolderPath(NULL, tmp, CSIDL_PERSONAL,FALSE))  {
<a name="l00740"></a>00740    <span class="comment">// TODO: get dynamicaly another possible path</span>
<a name="l00741"></a>00741    <span class="comment">// the following is only a workaround!</span>
<a name="l00742"></a>00742    <span class="keywordflow">return</span> <span class="stringliteral">&quot;C:\\OpenLieroX&quot;</span>;
<a name="l00743"></a>00743   }
<a name="l00744"></a>00744   fix_markend(tmp);
<a name="l00745"></a>00745 
<a name="l00746"></a>00746   result = SystemNativeToUtf8(tmp);
<a name="l00747"></a>00747  }
<a name="l00748"></a>00748  <span class="keywordflow">return</span> result;
<a name="l00749"></a>00749 <span class="preprocessor">#endif</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span>}
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 std::string GetSystemDataDir() {
<a name="l00754"></a>00754 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00755"></a>00755 <span class="preprocessor"></span> <span class="keywordflow">return</span> SYSTEM_DATA_DIR;
<a name="l00756"></a>00756 <span class="preprocessor">#else</span>
<a name="l00757"></a>00757 <span class="preprocessor"></span> <span class="comment">// windows don&#39;t have such dir, don&#39;t it?</span>
<a name="l00758"></a>00758  <span class="comment">// or should we return windows/system32 (which is not exactly intended here)?</span>
<a name="l00759"></a>00759  <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00760"></a>00760 <span class="preprocessor">#endif</span>
<a name="l00761"></a>00761 <span class="preprocessor"></span>}
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 
<a name="l00764"></a>00764 std::string binary_dir; <span class="comment">// given by argv[0], set by main()</span>
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 std::string GetBinaryDir() {
<a name="l00767"></a>00767  <span class="keywordflow">return</span> binary_dir;
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 std::string GetTempDir() {
<a name="l00771"></a>00771 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00772"></a>00772 <span class="preprocessor"></span> <span class="keywordflow">return</span> <span class="stringliteral">&quot;/tmp&quot;</span>; <span class="comment">// year, it&#39;s so simple :)</span>
<a name="l00773"></a>00773 <span class="preprocessor">#else</span>
<a name="l00774"></a>00774 <span class="preprocessor"></span> <span class="keyword">static</span> <span class="keywordtype">char</span> buf[1024] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00775"></a>00775  <span class="keywordflow">if</span>(buf[0] == <span class="charliteral">&#39;\0&#39;</span>) { <span class="comment">// only do this once</span>
<a name="l00776"></a>00776   GetTempPath(<span class="keyword">sizeof</span>(buf), buf);
<a name="l00777"></a>00777   fix_markend(buf);
<a name="l00778"></a>00778  }
<a name="l00779"></a>00779  <span class="keywordflow">return</span> SystemNativeToUtf8(buf);
<a name="l00780"></a>00780 <span class="preprocessor">#endif</span>
<a name="l00781"></a>00781 <span class="preprocessor"></span>}
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="keywordtype">void</span> ReplaceFileVariables(std::string&amp; filename) {
<a name="l00784"></a>00784  <span class="keywordflow">if</span>(filename.compare(0,2,<span class="stringliteral">&quot;~/&quot;</span>)==0
<a name="l00785"></a>00785     || filename.compare(0,2,<span class="stringliteral">&quot;~\\&quot;</span>)==0
<a name="l00786"></a>00786     || filename == <span class="stringliteral">&quot;~&quot;</span>) {
<a name="l00787"></a>00787   filename.erase(0,1);
<a name="l00788"></a>00788   filename.insert(0,GetHomeDir());
<a name="l00789"></a>00789  }
<a name="l00790"></a>00790  replace(filename, <span class="stringliteral">&quot;${HOME}&quot;</span>, GetHomeDir());
<a name="l00791"></a>00791  replace(filename, <span class="stringliteral">&quot;${SYSTEM_DATA}&quot;</span>, GetSystemDataDir());
<a name="l00792"></a>00792  replace(filename, <span class="stringliteral">&quot;${BIN}&quot;</span>, GetBinaryDir());
<a name="l00793"></a>00793 }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 <span class="comment">// WARNING: not multithreading aware</span>
<a name="l00796"></a>00796 <span class="comment">// HINT: uses absolute paths</span>
<a name="l00797"></a>00797 <span class="comment">// returns true, if successfull</span>
<a name="l00798"></a>00798 <span class="keywordtype">bool</span> FileCopy(<span class="keyword">const</span> std::string&amp; src, <span class="keyword">const</span> std::string&amp; dest) {
<a name="l00799"></a>00799  <span class="keyword">static</span> <span class="keywordtype">char</span> tmp[2048];
<a name="l00800"></a>00800 
<a name="l00801"></a>00801  notes &lt;&lt; <span class="stringliteral">&quot;FileCopy: &quot;</span> &lt;&lt; src &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; dest &lt;&lt; endl;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803  FILE* src_f = fopen(Utf8ToSystemNative(src).c_str(), <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00804"></a>00804 
<a name="l00805"></a>00805  <span class="keywordflow">if</span>(!src_f) {
<a name="l00806"></a>00806   errors &lt;&lt; <span class="stringliteral">&quot;FileCopy: cannot open source&quot;</span> &lt;&lt; endl;
<a name="l00807"></a>00807   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00808"></a>00808  }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810  FILE* dest_f = fopen(Utf8ToSystemNative(dest).c_str(), <span class="stringliteral">&quot;wb&quot;</span>);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812  <span class="keywordflow">if</span>(!dest_f) {
<a name="l00813"></a>00813   fclose(src_f);
<a name="l00814"></a>00814   errors &lt;&lt; <span class="stringliteral">&quot;FileCopy: cannot open destination&quot;</span> &lt;&lt; endl;
<a name="l00815"></a>00815   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00816"></a>00816  }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818  <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;
<a name="l00819"></a>00819  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> count = 0;
<a name="l00820"></a>00820  notes &lt;&lt; <span class="stringliteral">&quot;FileCopy: |&quot;</span> &lt;&lt; flush;
<a name="l00821"></a>00821  <span class="keywordtype">size_t</span> len = 0;
<a name="l00822"></a>00822  <span class="keywordflow">while</span>((len = fread(tmp, 1, <span class="keyword">sizeof</span>(tmp), src_f)) &gt; 0) {
<a name="l00823"></a>00823   <span class="keywordflow">if</span>(count == 0) notes &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; flush; count++; count %= 20;
<a name="l00824"></a>00824   <span class="keywordflow">if</span>(len != fwrite(tmp, 1, len, dest_f)) {
<a name="l00825"></a>00825    errors &lt;&lt; <span class="stringliteral">&quot;FileCopy: problem while writing&quot;</span> &lt;&lt; endl;
<a name="l00826"></a>00826    success = <span class="keyword">false</span>;
<a name="l00827"></a>00827    <span class="keywordflow">break</span>;
<a name="l00828"></a>00828   }
<a name="l00829"></a>00829   <span class="keywordflow">if</span>(len != <span class="keyword">sizeof</span>(tmp)) <span class="keywordflow">break</span>;
<a name="l00830"></a>00830  }
<a name="l00831"></a>00831  notes &lt;&lt; endl;
<a name="l00832"></a>00832  <span class="keywordflow">if</span>(success) {
<a name="l00833"></a>00833   success = feof(src_f) != 0;
<a name="l00834"></a>00834   <span class="keywordflow">if</span>(!success) errors &lt;&lt; <span class="stringliteral">&quot;FileCopy: problem while reading&quot;</span> &lt;&lt; endl;
<a name="l00835"></a>00835  }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837  fclose(src_f);
<a name="l00838"></a>00838  fclose(dest_f);
<a name="l00839"></a>00839  <span class="keywordflow">if</span>(success) notes &lt;&lt; <span class="stringliteral">&quot;FileCopy: success :)&quot;</span> &lt;&lt; endl;
<a name="l00840"></a>00840  <span class="keywordflow">return</span> success;
<a name="l00841"></a>00841 }
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 <span class="keywordtype">bool</span> CanWriteToDir(<span class="keyword">const</span> std::string&amp; dir) {
<a name="l00844"></a>00844  <span class="comment">// TODO: we have to make this a lot better!</span>
<a name="l00845"></a>00845  std::string fname = dir + <span class="stringliteral">&quot;/.some_stupid_temp_file&quot;</span>;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847  FILE* fp = fopen(Utf8ToSystemNative(fname).c_str(), <span class="stringliteral">&quot;w&quot;</span>);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849  <span class="keywordflow">if</span>(fp) {
<a name="l00850"></a>00850   fclose(fp);
<a name="l00851"></a>00851   <span class="keyword">remove</span>(Utf8ToSystemNative(fname).c_str());
<a name="l00852"></a>00852 
<a name="l00853"></a>00853   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00854"></a>00854  }
<a name="l00855"></a>00855  <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00856"></a>00856 }
<a name="l00857"></a>00857 
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 std::string GetAbsolutePath(<span class="keyword">const</span> std::string&amp; path) {
<a name="l00860"></a>00860 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00861"></a>00861 <span class="preprocessor"></span> std::string exactpath;
<a name="l00862"></a>00862  <span class="keywordflow">if</span> (!GetExactFileName(path, exactpath))
<a name="l00863"></a>00863   exactpath = path;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865  <span class="keywordtype">char</span> buf[2048];
<a name="l00866"></a>00866  <span class="keywordtype">int</span> len = GetFullPathName(Utf8ToSystemNative(exactpath).c_str(), <span class="keyword">sizeof</span>(buf), buf, NULL);
<a name="l00867"></a>00867  fix_markend(buf);
<a name="l00868"></a>00868  <span class="keywordflow">if</span> (len)
<a name="l00869"></a>00869   <span class="keywordflow">return</span> SystemNativeToUtf8(buf);
<a name="l00870"></a>00870  <span class="keywordflow">else</span>  <span class="comment">// Failed</span>
<a name="l00871"></a>00871   <span class="keywordflow">return</span> path;
<a name="l00872"></a>00872 <span class="preprocessor">#else</span>
<a name="l00873"></a>00873 <span class="preprocessor"></span> std::string exactpath;
<a name="l00874"></a>00874  <span class="keywordflow">if</span>(GetExactFileName(path, exactpath)) {
<a name="l00875"></a>00875   <span class="keywordtype">char</span> buf[PATH_MAX];
<a name="l00876"></a>00876   <span class="keywordflow">if</span>(realpath(exactpath.c_str(), buf) != NULL) {
<a name="l00877"></a>00877    fix_markend(buf);
<a name="l00878"></a>00878    <span class="keywordflow">return</span> buf;
<a name="l00879"></a>00879   } <span class="keywordflow">else</span>
<a name="l00880"></a>00880    <span class="keywordflow">return</span> exactpath;
<a name="l00881"></a>00881  } <span class="keywordflow">else</span>
<a name="l00882"></a>00882   <span class="keywordflow">return</span> path;
<a name="l00883"></a>00883 <span class="preprocessor">#endif</span>
<a name="l00884"></a>00884 <span class="preprocessor"></span>}
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 <span class="keywordtype">bool</span> PathListIncludes(<span class="keyword">const</span> std::list&lt;std::string&gt;&amp; pathlist, <span class="keyword">const</span> std::string&amp; path) {
<a name="l00887"></a>00887  std::string abs_path;
<a name="l00888"></a>00888  abs_path = GetAbsolutePath(path);
<a name="l00889"></a>00889 
<a name="l00890"></a>00890  <span class="comment">// Go through the list, checking each item</span>
<a name="l00891"></a>00891  <span class="keywordflow">for</span>(std::list&lt;std::string&gt;::const_iterator i = pathlist.begin(); i != pathlist.end(); i++) {
<a name="l00892"></a>00892   <span class="keywordflow">if</span>(EqualPaths(abs_path, GetAbsolutePath(*i))) {
<a name="l00893"></a>00893    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00894"></a>00894   }
<a name="l00895"></a>00895  }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897  <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 <span class="comment"></span>
<a name="l00900"></a>00900 <span class="comment">///////////////////////</span>
<a name="l00901"></a>00901 <span class="comment"></span><span class="comment">// Returns the file contents as a string</span>
<a name="l00902"></a>00902 std::string GetFileContents(<span class="keyword">const</span> std::string&amp; path, <span class="keywordtype">bool</span> absolute)
<a name="l00903"></a>00903 {
<a name="l00904"></a>00904  FILE *fp = NULL;
<a name="l00905"></a>00905  <span class="keywordflow">if</span> (absolute)
<a name="l00906"></a>00906   fp = fopen(<span class="comment">/*Utf8ToSystemNative(path)*/</span>path.c_str(), <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00907"></a>00907  <span class="keywordflow">else</span>
<a name="l00908"></a>00908   fp = OpenGameFile(path, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910  <span class="keywordflow">if</span> (!fp)
<a name="l00911"></a>00911   <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913  fseek(fp, 0, SEEK_END);
<a name="l00914"></a>00914  <span class="keywordtype">size_t</span> size = ftell(fp);
<a name="l00915"></a>00915  fseek(fp, 0, SEEK_SET);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917  <span class="keywordflow">if</span> (!size)  {
<a name="l00918"></a>00918   fclose(fp);
<a name="l00919"></a>00919   <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00920"></a>00920  }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922  <span class="keywordtype">char</span> *buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[size];
<a name="l00923"></a>00923  size = fread(buf, 1, size, fp);
<a name="l00924"></a>00924  <span class="keywordflow">if</span> (!size)  {
<a name="l00925"></a>00925   <span class="keyword">delete</span>[] buf;
<a name="l00926"></a>00926   fclose(fp);
<a name="l00927"></a>00927   <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00928"></a>00928  }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930  std::string result;
<a name="l00931"></a>00931  result.append(buf, size);
<a name="l00932"></a>00932  <span class="keyword">delete</span>[] buf;
<a name="l00933"></a>00933  fclose(fp);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935  <span class="keywordflow">return</span> result;
<a name="l00936"></a>00936 }
<a name="l00937"></a>00937 <span class="comment"></span>
<a name="l00938"></a>00938 <span class="comment">////////////////</span>
<a name="l00939"></a>00939 <span class="comment"></span><span class="comment">// Extract the directory part from a path</span>
<a name="l00940"></a>00940 std::string ExtractDirectory(<span class="keyword">const</span> std::string&amp; path)
<a name="l00941"></a>00941 {
<a name="l00942"></a>00942  <span class="keywordflow">if</span> (path.size() == 0)
<a name="l00943"></a>00943   <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00944"></a>00944 
<a name="l00945"></a>00945  <span class="keywordtype">size_t</span> pos = findLastPathSep(path);
<a name="l00946"></a>00946  <span class="keywordflow">if</span> (pos == std::string::npos)
<a name="l00947"></a>00947   <span class="keywordflow">return</span> path;
<a name="l00948"></a>00948  <span class="keywordflow">else</span>
<a name="l00949"></a>00949   <span class="keywordflow">return</span> path.substr(0, pos);
<a name="l00950"></a>00950 }
<a name="l00951"></a>00951 
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 std::string GetScriptInterpreterCommandForFile(<span class="keyword">const</span> std::string&amp; filename) {
<a name="l00954"></a>00954  FILE* f = OpenGameFile(filename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00955"></a>00955  <span class="keywordflow">if</span>(f) {
<a name="l00956"></a>00956   std::string line = ReadUntil(f);
<a name="l00957"></a>00957   <span class="keywordflow">if</span>(line.size() &gt; 2 &amp;&amp; line[0] == <span class="charliteral">&#39;#&#39;</span> &amp;&amp; line[1] == <span class="charliteral">&#39;!&#39;</span>) {
<a name="l00958"></a>00958    std::string cmd = line.substr(2);
<a name="l00959"></a>00959    TrimSpaces(cmd);
<a name="l00960"></a>00960    fclose(f);
<a name="l00961"></a>00961    <span class="keywordflow">return</span> cmd;
<a name="l00962"></a>00962   }
<a name="l00963"></a>00963   fclose(f);
<a name="l00964"></a>00964   <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00965"></a>00965  }
<a name="l00966"></a>00966  <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00967"></a>00967 }
<a name="l00968"></a>00968 
<a name="l00969"></a>00969 <span class="comment"></span>
<a name="l00970"></a>00970 <span class="comment">///////////////////</span>
<a name="l00971"></a>00971 <span class="comment"></span><span class="comment">// Merges two parts of a path into one, for example JoinPath(&quot;./test/&quot;, &quot;/file.fil&quot;) gives &quot;./test/file.fil&quot;</span>
<a name="l00972"></a>00972 std::string JoinPaths(<span class="keyword">const</span> std::string&amp; path1, <span class="keyword">const</span> std::string&amp; path2)
<a name="l00973"></a>00973 {
<a name="l00974"></a>00974  <span class="keywordflow">if</span> (path1.size() == 0)
<a name="l00975"></a>00975   <span class="keywordflow">return</span> path2;
<a name="l00976"></a>00976  <span class="keywordflow">if</span> (path2.size() == 0)
<a name="l00977"></a>00977   <span class="keywordflow">return</span> path1;
<a name="l00978"></a>00978 
<a name="l00979"></a>00979  std::string result = path1;
<a name="l00980"></a>00980  <span class="keywordflow">if</span> (*path1.rbegin() == <span class="charliteral">&#39;/&#39;</span> || *path1.rbegin() == <span class="charliteral">&#39;\\&#39;</span>)  {
<a name="l00981"></a>00981   <span class="keywordflow">if</span> (*path2.begin() == <span class="charliteral">&#39;/&#39;</span> || *path2.begin() == <span class="charliteral">&#39;\\&#39;</span>)  {
<a name="l00982"></a>00982    result.erase(result.size() - 1);
<a name="l00983"></a>00983    result += path2;
<a name="l00984"></a>00984    <span class="keywordflow">return</span> result;
<a name="l00985"></a>00985   } <span class="keywordflow">else</span> {
<a name="l00986"></a>00986    result += path2;
<a name="l00987"></a>00987    <span class="keywordflow">return</span> result;
<a name="l00988"></a>00988   }
<a name="l00989"></a>00989  } <span class="keywordflow">else</span> {
<a name="l00990"></a>00990   <span class="keywordflow">if</span> (*path2.begin() == <span class="charliteral">&#39;/&#39;</span> || *path2.begin() == <span class="charliteral">&#39;\\&#39;</span>)  {
<a name="l00991"></a>00991    result += path2;
<a name="l00992"></a>00992    <span class="keywordflow">return</span> result;
<a name="l00993"></a>00993   } <span class="keywordflow">else</span> {
<a name="l00994"></a>00994    result += <span class="charliteral">&#39;/&#39;</span>;
<a name="l00995"></a>00995    result += path2;
<a name="l00996"></a>00996    <span class="keywordflow">return</span> result;
<a name="l00997"></a>00997   }
<a name="l00998"></a>00998  }
<a name="l00999"></a>00999 }
<a name="l01000"></a>01000 <span class="comment"></span>
<a name="l01001"></a>01001 <span class="comment">//////////////////////////////</span>
<a name="l01002"></a>01002 <span class="comment"></span><span class="comment">// Creating SDL_RWops structure from a file pointer</span>
<a name="l01003"></a>01003 <span class="comment">// We cannot use SDL&#39;s function for this under WIN32 because it doesn&#39;t allow</span>
<a name="l01004"></a>01004 <span class="comment">// passing file pointers to a dll</span>
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="preprocessor">#include &lt;SDL.h&gt;</span>
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="comment">// These are taken from SDL_rwops.c</span>
<a name="l01009"></a>01009 <span class="preprocessor">#ifdef WIN32</span>
<a name="l01010"></a>01010 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> stdio_seek(SDL_RWops *context, <span class="keywordtype">int</span> offset, <span class="keywordtype">int</span> whence)
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012  <span class="keywordflow">if</span> ( fseek(context-&gt;hidden.stdio.fp, offset, whence) == 0 ) {
<a name="l01013"></a>01013   <span class="keywordflow">return</span>(ftell(context-&gt;hidden.stdio.fp));
<a name="l01014"></a>01014  } <span class="keywordflow">else</span> {
<a name="l01015"></a>01015   SDL_Error(SDL_EFSEEK);
<a name="l01016"></a>01016   <span class="keywordflow">return</span>(-1);
<a name="l01017"></a>01017  }
<a name="l01018"></a>01018 }
<a name="l01019"></a>01019 <span class="keyword">static</span> <span class="keywordtype">int</span> stdio_read(SDL_RWops *context, <span class="keywordtype">void</span> *ptr, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> maxnum)
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021  <span class="keywordtype">size_t</span> nread;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023  nread = fread(ptr, size, maxnum, context-&gt;hidden.stdio.fp);
<a name="l01024"></a>01024  <span class="keywordflow">if</span> ( nread == 0 &amp;&amp; ferror(context-&gt;hidden.stdio.fp) ) {
<a name="l01025"></a>01025   SDL_Error(SDL_EFREAD);
<a name="l01026"></a>01026  }
<a name="l01027"></a>01027  <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(nread);
<a name="l01028"></a>01028 }
<a name="l01029"></a>01029 <span class="keyword">static</span> <span class="keywordtype">int</span> stdio_write(SDL_RWops *context, <span class="keyword">const</span> <span class="keywordtype">void</span> *ptr, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> num)
<a name="l01030"></a>01030 {
<a name="l01031"></a>01031  <span class="keywordtype">size_t</span> nwrote;
<a name="l01032"></a>01032 
<a name="l01033"></a>01033  nwrote = fwrite(ptr, size, num, context-&gt;hidden.stdio.fp);
<a name="l01034"></a>01034  <span class="keywordflow">if</span> ( nwrote == 0 &amp;&amp; ferror(context-&gt;hidden.stdio.fp) ) {
<a name="l01035"></a>01035   SDL_Error(SDL_EFWRITE);
<a name="l01036"></a>01036  }
<a name="l01037"></a>01037  <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(nwrote);
<a name="l01038"></a>01038 }
<a name="l01039"></a>01039 <span class="keyword">static</span> <span class="keywordtype">int</span> stdio_close(SDL_RWops *context)
<a name="l01040"></a>01040 {
<a name="l01041"></a>01041  <span class="keywordflow">if</span> ( context ) {
<a name="l01042"></a>01042   <span class="keywordflow">if</span> ( context-&gt;hidden.stdio.autoclose ) {
<a name="l01043"></a>01043    <span class="comment">/* WARNING:  Check the return value here! */</span>
<a name="l01044"></a>01044    fclose(context-&gt;hidden.stdio.fp);
<a name="l01045"></a>01045   }
<a name="l01046"></a>01046   free(context);
<a name="l01047"></a>01047  }
<a name="l01048"></a>01048  <span class="keywordflow">return</span>(0);
<a name="l01049"></a>01049 }
<a name="l01050"></a>01050 <span class="preprocessor">#endif</span>
<a name="l01051"></a>01051 <span class="preprocessor"></span><span class="comment"></span>
<a name="l01052"></a>01052 <span class="comment">////////////////</span>
<a name="l01053"></a>01053 <span class="comment"></span><span class="comment">// Creates SDL_RWops from a file pointer</span>
<a name="l01054"></a>01054 SDL_RWops *RWopsFromFP(FILE *fp, <span class="keywordtype">bool</span> autoclose)  {
<a name="l01055"></a>01055 <span class="preprocessor">#ifdef WIN32</span>
<a name="l01056"></a>01056 <span class="preprocessor"></span> <span class="comment">// Taken from SDL code</span>
<a name="l01057"></a>01057  SDL_RWops *rwops = SDL_AllocRW();
<a name="l01058"></a>01058  <span class="keywordflow">if</span> ( rwops != NULL ) {
<a name="l01059"></a>01059   rwops-&gt;seek = stdio_seek;
<a name="l01060"></a>01060   rwops-&gt;read = stdio_read;
<a name="l01061"></a>01061   rwops-&gt;write = stdio_write;
<a name="l01062"></a>01062   rwops-&gt;close = stdio_close;
<a name="l01063"></a>01063   rwops-&gt;hidden.stdio.fp = fp;
<a name="l01064"></a>01064   rwops-&gt;hidden.stdio.autoclose = (int)autoclose;
<a name="l01065"></a>01065  }
<a name="l01066"></a>01066  <span class="keywordflow">return</span>(rwops);
<a name="l01067"></a>01067 
<a name="l01068"></a>01068 <span class="preprocessor">#else</span>
<a name="l01069"></a>01069 <span class="preprocessor"></span> <span class="keywordflow">return</span> SDL_RWFromFP(fp, (SDL_bool)autoclose);
<a name="l01070"></a>01070 <span class="preprocessor">#endif</span>
<a name="l01071"></a>01071 <span class="preprocessor"></span>}
<a name="l01072"></a>01072 
<a name="l01073"></a>01073 <span class="keywordtype">bool</span> Rename(<span class="keyword">const</span> std::string&amp; oldpath, <span class="keyword">const</span> std::string&amp; newpath) {
<a name="l01074"></a>01074  std::string searchpath;
<a name="l01075"></a>01075  std::string fulloldpath = GetFullFileName(oldpath, &amp;searchpath);
<a name="l01076"></a>01076  <span class="keywordflow">if</span>(searchpath == <span class="stringliteral">&quot;&quot;</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// not found</span>
<a name="l01077"></a>01077  <span class="keywordflow">if</span>(fulloldpath == <span class="stringliteral">&quot;&quot;</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// not found (double check, just to be sure)</span>
<a name="l01078"></a>01078  ReplaceFileVariables(searchpath);
<a name="l01079"></a>01079  std::string fullnewpath = searchpath + <span class="stringliteral">&quot;/&quot;</span> + newpath;
<a name="l01080"></a>01080  <span class="keywordflow">return</span> rename(fulloldpath.c_str(), fullnewpath.c_str()) == 0;
<a name="l01081"></a>01081 }
<a name="l01082"></a>01082 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
